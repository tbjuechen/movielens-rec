# 召回阶段技术白皮书 (Recall Layer Technical Report)

## 1. 召回阶段目标
召回（Recall）是推荐系统的第一级漏斗。面对 MovieLens 32M 中 **8.7 万部** 电影，其核心任务是：
- **高效率**：从全量电影中快速筛选出 **500~1000** 部候选片单。
- **高召回率**：确保用户真正可能感兴趣的电影尽早出现在候选集中。
- **多维度**：通过不同策略覆盖用户的多样化兴趣（热门、个性化、内容相关性）。

## 2. 架构设计：多路召回 (Multi-channel Recall)
本项目采用了工业界标准的并行多路召回架构，所有通道均继承自 `BaseRecall` 抽象基类，保证了接口的统一性。

| 召回路 | 技术方案 | 核心价值 | 状态 |
| :--- | :--- | :--- | :--- |
| **Popularity** | 离线统计 + 缓存榜单 | 保证新用户的基本体验，捕捉全局流行趋势。 | 已完成 |
| **ItemCF** | 稀疏矩阵 + Cosine 相似度 | 捕捉“看了又看”的共现关系，极强的个性化解释性。 | 已完成 |
| **Two-Tower V2** | PyTorch + MLP + Faiss | 融合多模态特征，解决冷启动并提升长尾覆盖。 | 已完成 |

## 3. 通道实现细节

### 3.1 热门召回 (Popularity Recall)
- **逻辑**：统计电影在训练集中的交互频次。
- **优化**：实现了 **“已看过滤” (Seen Filter)**。模型会持久化每个用户的观影历史，在线召回时自动剔除已观影片，提升推荐的新颖度。

### 3.2 基于物品的协同过滤 (ItemCF)
- **工程挑战**：3200 万交互导致的共现矩阵爆炸。
- **解决方案**：
    - 使用 `scipy.sparse` 构建稀疏矩阵。
    - **矩阵剪枝**：每部电影仅保留最相似的 **Top-50** 个邻居，将模型体积压缩了 90% 以上。
- **在线召回**：根据用户历史兴趣，实时加权聚合相似电影。

### 3.3 多模态双塔模型 (Two-Tower V2)
- **网络结构**：
    - **User Tower**: UserID Embedding + User Genres (Mean Pooling) + User Stats.
    - **Item Tower**: MovieID Embedding + Movie Genres (Mean Pooling) + Item Stats.
- **检索引擎**：整合 **Faiss (IndexFlatIP)** 向量数据库，通过内积搜索实现毫秒级召回。
- **性能优化**：针对 Apple Silicon (MPS) 手动实现了 Embedding 平均池化，替代了兼容性较差的 `nn.EmbeddingBag`。

## 4. 负采样策略 (Negative Sampling)
在双塔模型的训练中，采用 **In-batch Negative Sampling**：
- **逻辑**：将同一批次（Batch）内其他用户的正向交互物品作为当前用户的负样本。
- **红利**：Batch Size（如 8192）越大，负样本越丰富，模型对“全局空间”的判别能力越强。

## 5. 评估体系与数据闭环

### 5.1 数据准备
- **切分方式**：80/10/10 全局时间序列切分，严禁随机切分以防止“时间穿越”导致的数据泄露。
- **ID 编码**：实现了全自动的 ID 连续化重映射逻辑。

### 5.2 评估指标 (HitRate@K)
对于 1000 名采样测试用户，计算其未来行为被各召回路命中的比例：
- **核心经验**：ItemCF 训练必须与评估使用同一套训练集切片，否则会因“历史记录污染”导致召回率为 0。

## 6. 后续演进规划
1. **Graph-based Recall**：引入 GraphSAGE 等图神经网络捕捉更高阶的“物品-用户”关系。
2. **LogQ 修正**：针对双塔模型中的流行度偏差进行数学修正。
3. **多路合并策略**：目前三路召回是孤立的，下一步将引入排序模型（Ranking）进行统一打分。
